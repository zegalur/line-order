
import matplotlib.pyplot as plt
import numpy as np
import copy

from .utils import get_line_eq_coefficients, get_intersection_point, svg_header


def draw_pseudolines(
        table, 
        size_px=900, 
        line_width_px=1.5, 
        show_plot=False,
        title_text="Generated by LineOrder",
        ):
    """This function generates a visual representation of a pseudoline 
    arrangement where each pair of lines intersects at distinct points, 
    as specified in a table. Refer to README.md for details on the table format.

    Arguments:
        `table` -- A table of the arrangement of pseudolines.
        `size_px` -- SVG image size (in pixels).
        `line_width_px` -- Line width (in pixels).
        `show_plot` -- If `True`, will show representation in a pop-up window.
        `title_text` -- A title text ("Generated by LineOrder" by default).

    Returns a dictionary:
        `status` -- Status of the operation (`OK` or `ERROR: [...]`).
        `svg` -- SVG image of a visual representation of the arrangement.
        `order_list` -- A table with rows showing how order changes \
            from the outside towards the center of the circle.
        `cross_points` -- A table with rows showing the order of cross-points \
            from the outside towards the center of the circle.
    """

    input = copy.deepcopy(table)

    # N is the number of pseudolines in the arrangement.
    N = len(input)

    # The initial order of lines. Positive numbers are for lines that goes
    # into the circle, negative is for lines that goes out from the circle.
    # Because each line intersects each other line, the initial order will be:
    # [ 1,2,...,N, -1,-2,...,-N ]
    order = list(range(1, N+1)) + list(range(-1, -(N+1), -1))

    # A table with rows showing how order changes from the outside towards 
    # the center of the circle.
    order_list = [order.copy()]

    # A table with rows showing the order of cross-points from the outside 
    # towards the center of the circle.
    cross_points = []

    # Iterate until we can't get another cross point.
    while True:

        # What lines where flipped in this round.
        flipped = []

        # What cross points we get in this round.
        round_cross_points = []

        # Remove the lines with no cross-points left from the consideration.

        removed = True
        while removed:
            removed = False
            for i in range(N):
                if len(input[i]) == 0 and ((i+1) in order):
                    order[order.index( (i + 1))] = 0
                    order[order.index(-(i + 1))] = 0
                    removed = True
                    break

        # Iterate trough the current order and flip the non-removed adjacent 
        # lines.

        for i in range(len(order)):
            if order[i] == 0:
                # i-th line was already removed, skip.
                continue
            
            i1, i2 = i, i

            # Find the next non-removed adjacent line to i-th line.

            for w in range(N):
                i2 += 1
                i2 %= len(order)
                if order[i2] != 0:
                    # i2-th line hasn't been removed yet.
                    break
            if order[i2] == 0:
                break

            # Check if this two lines can be flipped according to the table.

            a, b = order[i1], order[i2]
            if a in flipped: continue
            if b in flipped: continue
            u, v = abs(a) - 1, abs(b) - 1
            if len(input[u]) == 0: continue
            if len(input[v]) == 0: continue
            m = 0 if a > 0 else len(input[u]) - 1
            n = 0 if b > 0 else len(input[v]) - 1
            x, y = input[u][m], input[v][n]
            if (u == y - 1) and (v == x - 1):
                # This two lines should be flipped.
                flipped.append(a)
                flipped.append(b)
                round_cross_points.append((a, b))
                input[u].pop(m)
                input[v].pop(n)
                order[i1], order[i2] = b, a

        # No new cross-points, stop the cycle
        if len(round_cross_points) == 0:
            break

        # Save the information about this round.
        cross_points.append(round_cross_points)
        order_list.append(order.copy())


    # Construct the graphical representation.

    style = 'path { fill: none; stroke-width:' + str(line_width_px) + 'px }'
    svg = svg_header.format(style=style, width_px=size_px, height_px=size_px)
    
    # Add the info text to the SVG.
    svg += '''
    <text x='20' y='30'>({} pseudolines)</text>
    <text x='20' y='45'>{}</text>\n
    '''.format(N, title_text)

    colors = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"]
    styles = ['solid', 'dashed', 'dashdot', 'dotted']
    da_values = ["6,2", "6,2,2,2", "2,2"]
    dasharrays = [""] + ["stroke-dasharray='{}'".format(v) for v in da_values]

    # [ 1,2,...,N, -1,-2,...,-N ]
    numbers = list(range(1, N+1)) + list(range(-1, -(N+1), -1))

    # Line segment positions for each line.
    xss, yss = [], []

    # Collect the line segment positions for each line and each round.

    for index in range(2 * N):
        prev_pos = -1
        i = numbers[index]
        xs, ys = [], []
        for k in range(len(order_list)):
            if (i in order_list[k]) == False:
                break
            pos = order_list[k].index(i)
            if pos == prev_pos:
                continue
            if prev_pos == -1: 
                prev_pos = pos
            a1 = 2.0 * np.pi * pos / (2.0 * N)
            r1 = 1.0 - k / (len(order_list) + 1.0)
            a2 = 2.0 * np.pi * prev_pos / (2.0 * N)
            r2 = 1.0 - (k - 1) / (len(order_list) + 1.0)

            l1 = get_line_eq_coefficients(
                    r1*np.cos(a1), -r1*np.sin(a1), r2*np.cos(a2), -r2*np.sin(a2))
            l2 = get_line_eq_coefficients(
                    r1*np.cos(a2), -r1*np.sin(a2), r2*np.cos(a1), -r2*np.sin(a1))
            
            cross_point = np.array([
                (r1 * np.cos(a1) + r2 * np.cos(a2)) * 0.5,
                -(r1 * np.sin(a1) + r2 * np.sin(a2)) * 0.5])
            
            if abs(np.dot(l1, l2)) < 1 - 1e-5:
                cross_point = get_intersection_point(l1, l2)

            xs.append(cross_point[0])
            ys.append(cross_point[1])
            
            prev_pos = pos

        xss.append(xs)
        yss.append(ys)

    # Reverse the segment points for lines that goes out from the circle.
    for i in range(N):
        xss[i+N].reverse()
        yss[i+N].reverse()

    # Show the plot window

    if show_plot:
        ax = plt.gca()
        ax.set_aspect('equal', adjustable='box')
        plt.axis('off')

        for i in range(N):
            plt.plot(xss[i] + xss[i + N], yss[i] + yss[i + N], 
                    linewidth = 1.1, 
                    linestyle = styles[(i // 10) % len(styles)],
                    color = colors[i % 10],
                    label = str(i + 1))
            r = 1.03
            plt.text(xss[i][0] * r, yss[i][0] * r, str(i + 1), )
            
        plt.xlim((-1.0, 1.0))
        plt.ylim((-1.0, 1.0))
        plt.show()

    # Construct the SVG

    # Save line labels positions
    labels = []
    for i in range(len(xss)):
        labels.append([( xss[i][0] * size_px * 0.82 + size_px) / 2,
                       (-yss[i][0] * size_px * 0.82 + size_px) / 2])

    # Scale and move the points
    for i in range(len(xss)):
        for j in range(len(xss[i])):
            xss[i][j] = ( xss[i][j] * size_px * 0.8 + size_px) / 2
            yss[i][j] = (-yss[i][j] * size_px * 0.8 + size_px) / 2

    # Add lines to the SVG
    for i in range(N):
        if (len(xss[i]) == 0) or (len(yss[i]) == 0):
            continue
        style = "stroke:{}".format(colors[i % 10])
        svg += '\t<path id="line{}" style="{}" {} d="M {} {} L'.format(
            i+1, style, dasharrays[(i // 10) % len(styles)], 
            xss[i][0], yss[i][0])
        for x,y in zip(xss[i] + xss[i + N], yss[i] + yss[i + N]):
            svg += " " + str(x) + " " + str(y)
        svg += '" />\n'

    # Add labels to the SVG
    svg += '\n'
    for i in range(N):
        svg += ("\t<text text-anchor='middle' dominant-baseline='middle'"
                +" x='{}' y='{}'>{}</text>\n").format(
                    labels[i][0], labels[i][1], i + 1)

    svg += "\n\t</svg>"

    result = {
        'status' : 'OK',
        'svg' : svg,
        'order_list' : order_list,
        'cross_points' : cross_points,
    }
    return result

